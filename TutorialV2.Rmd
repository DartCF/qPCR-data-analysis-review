---
title: "Efficiency and Stability in Quantitative PCR - Tutorial Notebook"
output:
  html_document:
    df_print: paged
    toc: true
---

# Introduction

This notebook serves as a companion to the paper demonstrating the analysis of covariance (ANCOVA) method as an alternative to the Delta-Delta-CT method for data analysis of quantitative real-time PCR (qPCR). Please refer to the pre-print **HERE** for a full exploration of those methods. 

This tutorial highlights quantitative and graphical tools that help researchers explore 1) sources of variability in qPCR and 2) the extent to which the reference gene used is a good candidate. 

In service to these aims we explore the following:

**Amplification efficiency**: Perfect amplification efficiency corresponds to a doubling of genetic material after every cycle. Perfect amplification efficiency is not often achieved in reality. We demonstrate methods to visualize amplification efficiency in your qPCR experiment in order to determine if it falls within an acceptable range and is not significantly different between reference and target genes. 

**CT variation of reference gene across treatment conditions**: A good reference gene will have stable expression across an experiment's treatment conditions. We demonstrate ways to explore this graphically and quantitatively. 

We end the tutorial by demonstrating the ANCOVA method for analyzing qPCR data. This method reveals whether or not the experimental perturbation of interest had an effect on target gene expression, accounting for the potential relationship between the expression of the reference and target genes. 

This tutorial makes use of the following packages, which need to be installed in your local R environment.

```{r message=F, warning=F}
library(readxl)
library(qpcR)
library(ctrlGene)
library(tidyverse)
library(gtools)
library(lme4)
```

The notebook includes functions that can be used with your own qPCR data in order to explore amplification efficiency and reference gene stability. To demonstrate the functions we use qPCR data generated by our lab. The qPCR experiment, run on Applied Biosystems' QuantStudio 3 Real-Time PCR System, measured expression of GAPDH (reference gene) and MMP10 (target gene) in primary human airway epithelial cells from donors with cystic fibrosis, exposed to either vehicle control (DMSO) or the modulator drug elexcaftor/tezacaftor/ivacaftor (ETI). ETI is a common therapy given to people with cystic fibrosis. Three samples for each donor and treatment combination were measured.

```{r}
qpcr_results_files <- c("./data/2024-03-07_GAPDH.xls","./data/2023-07-31_MMP10.xls")
qpcr_metadata_files <- c("./data/Experiment Key GAPDH.xlsx","./data/Experiment Key MMP10.xlsx")
# put file names in a list structure for our file ingestion functions
files_list <- list("GAPDH" = c(qpcr_results_files[1], qpcr_metadata_files[1]),
                   "MMP10" = c(qpcr_results_files[2], qpcr_metadata_files[2]))
```

# Selecting a Reference Gene: geNorm2

As highlighted above, it is important that reference genes have stable expression across experimental groups. In the process of selecting a reference gene we can use the `geNorm2` function from the `crtlGene` package to compare expression stability across multiple candidate reference genes.

`geNorm2` calculates a measure of expression stability, $M$, for each candidate reference gene it is provided. Lower values of $M$ correspond to higher stability across samples. Please see the [article](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2002-3-7-research0034) from Vandesompele et al for more information about how $M$ is calculated.

The input for the `geNorm2` function is a matrix of expression levels where columns correspond to candidate reference genes and rows correspond to unique samples, ideally covering all of the experimental conditions to be tested. In this example, expression levels are CTs calculated via qPCR for five reference gene candidates (GAPDH, GUSB, HPRT1, HSP90AB and UBC). 


```{r}
Ref.candidates <- read.csv("./data/CTmat_refs.csv", header = T, row.names = 1)
head(Ref.candidates)
```

Run `geNorm2` on the matrix of candidate reference genes, specifying that the expression values are CTs via the `ctVal` argument.  

```{r}
Ref.stability <- geNorm2(Ref.candidates, ctVal = T)
```

The output is a dataframe of the average stability $M$ for each of the genes. The most stable gene is in the last row of the dataframe and does not have an average $M$ recorded. This is because $M$ is a function of the log ratios of expression values for two genes across the samples. Average $M$ is the average standard deviation of all pairwise log ratios between the specified gene and all others. It is calculated step-wise, removing the least stable gene in each iteration. Therefore, the most stable gene's average $M$ is NA because all other genes have been eliminated from the calculation.

```{r}
Ref.stability
```

The following sections of the tutorial use GAPDH as the reference gene despite HSP90AB being identified as the most stable. GAPDH is a more commonly used reference gene and its stability measure $M$ falls below the often cited threshold of 1.5. 

# Exploring Amplification Efficiency

In order to calculate amplification efficiency we need the amplification data generated by a qPCR machine, which records the fluorescence signal at each round of amplification (cycle). Our lab uses the QuantStudio 3 machine running the QuantStudio Design and Analysis software v1.5.2, which generates results in Excel workbooks. Each workbook has an "Amplification Data" sheet which contains the amplification information for each well on a 96-well plate (see `2024-03-07_GAPDH.xls` and `2023-07-31_MMP10.xls`). 

The `ReadExcelAmplification` function extracts the amplification data from the generated Excel workbooks and joins it with experimental metadata. In this worked example, metadata is provided in the `Experiment Key GAPDPH.xlsx` and `Experiment Key MMP10.xlsx` files, which were created manually.

```{r}
ReadExcelAmplifcation <- function(results_file, metadata_file){
  # read data from provided excel spreadsheets
  # sheet argument specifies which sheet to read from the workbook
  # skip tells the function to not read the first 42 rows
  # name_repair tells the function to make column names play nice with R
  amp.curves <- read_excel(results_file, sheet = "Amplification Data", skip = 42, .name_repair = make.names)
  metadata <- read_excel(metadata_file, skip = 10)
  
  # join amplification data with metadata on the well position columns
  amp.curves.annotated <- amp.curves |> 
    inner_join(metadata, by=join_by("Well.Position"=="QPCR Well"))
  
  return(amp.curves.annotated)
}
```

Now that we have the amplification data, we can use the `pcrfit` and `efficiency` functions from the `qpcR` package to estimate the amplification efficiency from each well. 

`pcrfit` fits the amplification data, which records fluorescence signals at each amplification cycle, to a model (function). The `efficiency` function uses the fitted function's slope to estimate the amplification efficiency in the given sample across all cycles. 

`pcrfit` expects amplification data to be in a matrix with the first column specifying the cycle number (in increasing numeric order) and any following columns containing the fluorescence signals for wells on the qPCR plate. Therefore, any given column from 2 to $n$ has the fluorescence readings for a given well across all cycles in increasing cycle order.

First, get our qPCR data from the GAPDH and MMP10 experiments into the correct formats.

```{r}
# read in amplification data using the ReadExcelAmplification function defined above
# lapply runs this function on each element of the list "files_list" (each amplification file)
amp.curves.annotated <- lapply(files_list, function(x){
  ReadExcelAmplifcation(x[1], x[2])
})
names(amp.curves.annotated) <- names(files_list)

# format data for GAPDH and MMP10 into wide format where columns are well position and rows are cycles
GAPDH.amp.curves.annotated.wide <- amp.curves.annotated$GAPDH |> 
  pivot_wider(id_cols = Cycle,
              names_from = Well.Position,
              values_from = Delta.Rn)
MMP10.amp.curves.annotated.wide <- amp.curves.annotated$MMP10 |> 
  pivot_wider(id_cols=Cycle,
              names_from = Well.Position,
              values_from = Delta.Rn)

# preview correctly formatted data
head(GAPDH.amp.curves.annotated.wide)
```

The `GetEfficiencyEstimates` function is a wrapper around the `pcrfit` and `efficiency` functions. It expects data to be formatted as described above, and estimates amplification efficiency for each well represented in the input dataframe. It returns a named list, where each element corresponds to the amplification efficiency for a given well.

```{r}
GetEfficiencyEstimates <- function(amp.data){
  # run pcrfit using the l4 model, specifying the cycle ID and florescence columns
  pcrfit.models <- lapply(2:ncol(amp.data), function (well){
    pcrfit(as.data.frame(amp.data), cyc=1, fluo = well, model = l4)
  })
  # set the names (indexes) for the list to the well IDs
  well_ids <- unlist(lapply(pcrfit.models, function(m){m[["names"]]}))
  names(pcrfit.models) <- well_ids
  
  # extract efficiency estimates using the efficiency function
  # sapply, like lapply, applies a function to each element of the list but has the capability to return a vector (array)
  eff.estimates <- sapply(pcrfit.models, function (m){
    efficiency(m, method = "spline", plot = FALSE)[["eff"]]
  }, USE.NAMES = T, simplify = "array")
  
  return(eff.estimates)
}
```

`GraphEfficiencyEstimates` takes the named vector of efficiency estimates returned by `GetEfficiencyEstimates` and creates a plot of the estimated efficiencies. The mean efficiency across wells is plotted in red, with error bars representing $+/-$ one standard deviation. Dashed lines at $x=1$ and $x=2$ denote the range of possible values for amplification efficiency. An amplification efficiency of 2 is considered 100$\%$ efficiency and indicates that the material for the tagged gene doubles at every amplification cycle.

```{r}
GraphEfficiencyEstimates <- function(eff.data, ylab="Well ID"){
  # create dataframe representation of efficiency data, sorting well IDs alphabetically/numerically
  plot.df <- data.frame(Well=factor(names(eff.data), levels=rev(mixedsort(names(eff.data)))), 
                        Eff = eff.data)
  # create dataframe representation of efficiency descriptive stats (mean, +/- 1 SD)
  # also includes y-axis position for plotting, drawing the summary dot in the middle of the plot
  stats.df <- data.frame(Mean=mean(plot.df$Eff), 
                         Lower = mean(plot.df$Eff)-sd(plot.df$Eff),
                         Upper = mean(plot.df$Eff)+sd(plot.df$Eff),
                         ypos = levels(plot.df$Well)[floor(nrow(plot.df)/2)])
  
  # create ggplot object
  p.obj <- ggplot(data=plot.df, aes(y=Well, x=Eff))+
    geom_point()+ 
    geom_vline(xintercept = c(1,2), color="black", linetype="dashed")+
    geom_point(data=stats.df, aes(x=Mean, y=ypos, color="red"),size=2)+
    geom_errorbar(data=stats.df, aes(y=ypos, xmax = Upper, xmin = Lower), inherit.aes = F, color="red")+
    annotate("text",
             y=stats.df$ypos, 
             x=stats.df$Upper+0.2, 
             label=paste0("Mean(eff):",round(stats.df$Mean,2), "\n", "Std. Dev.(eff):", round(stats.df$Upper - stats.df$Mean,2)))+
    scale_color_manual(values = "red",labels = "Mean (+/- SD)")+
    theme_minimal()+
    theme(legend.position = "right", legend.justification.right = "top")+
    labs(x="Efficiency Estimate",
         y=ylab,
         color = "Error Bar")
  return(p.obj)
}
```

Estimate the amplification efficiencies for wells on the plate measuring GAPDH and plot.

```{r}
GAPDH.eff.estimates <- GetEfficiencyEstimates(GAPDH.amp.curves.annotated.wide)
GraphEfficiencyEstimates(GAPDH.eff.estimates)
```

Estimate the amplification efficiencies for wells on the plate measuring MMP10 and plot.

```{r}
MMP10.eff.estimates <- GetEfficiencyEstimates(MMP10.amp.curves.annotated.wide)
GraphEfficiencyEstimates(MMP10.eff.estimates)
```

The plots show amplification efficiency is ~ 1.5 for each well in the GAPDH and MMP10 plates and that there is a slight variation in amplification efficiency within each plate and between the reference and target genes. 

### Data with replicates

The `pcrfit` function can collapse replicates in a qPCR experiment. When `pcrfit` is invoked this way, a single estimate for amplification efficiency is calculated for each group of replicates. These values are very close to the average of the amplification efficiencies estimated for each sample in a replicate group.

```{r}
GetEfficiencyEstimates.Replicates <- function(amp.data.replicates){
  # run pcrfit using the l4 model, specifying the cycle ID column and 
  # florescence columns as a vector of all well's in the replicate group
  pcrfit.models <- lapply(amp.data.replicates, function (batch){
    pcrfit(as.data.frame(batch), cyc=1, fluo=2:ncol(batch), model = l4)
  })
  names(pcrfit.models) <- names(amp.data.replicates)

  # extract efficiency estimates
  eff.estimates <- sapply(pcrfit.models, function (m){
    efficiency(m, method = "spline", plot = FALSE)[["eff"]]
  }, USE.NAMES = T, simplify = "array")
  
  return(eff.estimates)
}
```

Use the same GAPDH and MMP10 data, this time collapsing replicates into a single efficiency estimate. First, prepare the data so each replicate group is represented in its own dataframe.

```{r}
amp.curves.annotated.replicates <- lapply(amp.curves.annotated, function(gene.data){
  # get replicate IDs from metadata
  replicate.ids <- unique(gene.data$`Sample Number for qPCR`)
  # generate wide-format data frame from each replicate group
  replicate.list <- lapply(replicate.ids, function(rep){
    rep.data <- gene.data |> 
      # filter for a given replicate group, denoted by the 'Sample Number for qPCR' column
      filter(`Sample Number for qPCR` == rep) |> 
      pivot_wider(id_cols = Cycle,
                  names_from = Well.Position,
                  values_from = Delta.Rn)
    return(rep.data)
  })
  names(replicate.list) <- replicate.ids
  return(replicate.list)
})
names(amp.curves.annotated.replicates) <- names(amp.curves.annotated)
```

Graph the estimated amplification efficiencies for GAPDH, collapsing replicates into a single estimation. 

```{r warning=F}
GAPDH.eff.estimates.reps <- GetEfficiencyEstimates.Replicates(amp.curves.annotated.replicates$GAPDH)
GraphEfficiencyEstimates(GAPDH.eff.estimates.reps, ylab = "Replicate Group")
```

Do the same for MMP10.

```{r warning=F}
MMP10.eff.estimates.reps <- GetEfficiencyEstimates.Replicates(amp.curves.annotated.replicates$MMP10)
GraphEfficiencyEstimates(MMP10.eff.estimates.reps, ylab = "Replicate Group")
```

We can update this graph to include more descriptive replicate group labels, utilizing the formatted metadata we created with the `ReadExcelAmplifcation` function. We'll take advantage of the `Sample Number for qPCR` column, which denotes replicate group membership for each qPCR well.

```{r}
CreateLabels <- function(amp.annotated){
  labels <- amp.annotated |> 
    select(`Sample Number for qPCR`, Treatment, Donor) |> 
    mutate(Group = paste(Donor, str_split_i(Treatment, "\\+ ",2))) |> 
    distinct() |> 
    arrange(`Sample Number for qPCR`)
  labels.list <- labels$Group
  return(labels.list)
}

names(MMP10.eff.estimates.reps) <- CreateLabels(amp.curves.annotated$MMP10)
names(GAPDH.eff.estimates.reps) <- CreateLabels(amp.curves.annotated$GAPDH)

GraphEfficiencyEstimates(MMP10.eff.estimates.reps, ylab = "Replicate Group")

GraphEfficiencyEstimates(GAPDH.eff.estimates.reps, ylab = "Replicate Group")
```
#  Cycle Thresholds (CT) for Target and Reference Genes

It is important to establish that the treatment does not affect the expression of the reference gene. In addition to exploring this quantitatively with geNorm, we can inspect this visually by plotting the CT values for the target and the reference genes, stratified by treatment. A good reference gene will demonstrate stable expression levels across experimental conditions.

First, we need to get the CT results generated by the qPCR machine. In doing this, we'll also see how data should be formatted for use with the ANCOVA method.

`ReadExcelCTResults` reads the same results file generated by the QuantStudio Design and Analysis software. Instead of extracting amplification data it extracts the cycle threshold information from the 'Results' sheet. Like the `ReadExcelAmplification` function, this function joins the results with the metadata.

```{r}
ReadExcelCTResults <- function(results_file, metadata_file){
  # read data from provided excel spreadsheets
  # sheet argument specifies which sheet to read from the workbook
  # skip tells the function to not read the first 42 rows
  # name_repair tells the function to make column names play nice with R
  results <- read_excel(results_file, sheet = "Results", skip = 42, .name_repair = make.names)
  metadata <- read_excel(metadata_file, skip = 10)
  
  # merge with the metadata
  results.merged <- results |> 
    inner_join(metadata, by=join_by("Well.Position" == "QPCR Well"))
  
  return(results.merged)
}
```

Using the same `files_list` variable defined in the preceding section, read in the CT results using `ReadExcelCTResults`.

```{r}
ct.results.annotated <- lapply(files_list, function(x){
  ReadExcelCTResults(x[1],x[2])
})
```

For the ANCOVA method, the CT data needs to be formatted so columns correspond to a gene and rows are unique samples. Values are the CT for the gene in a give sample. In this worked example, we use the average CT for three replicates. 

Used together the `FormatCT.Ancova` and `JoinCTResults` functions manipulate the data to conform to this format.

```{r}
FormatCT.ANCOVA <- function(CTResults, SampleCol="Sample.Name", DonorCol="Donor", TreatmentCol="Treatment", TargetCol="Target.Name", CTCol="Ct.Mean"){
  # extract the columns we're interested in: Sample ID, Donor ID, Treatment, Gene Name and CT
  formatted <- CTResults |> 
    select(all_of(c(SampleCol, DonorCol, TreatmentCol, TargetCol, CTCol))) |> 
    # by default we take the mean CT data from the CT results, so keep only distinct combinations of the selected columns
    distinct()
  return(formatted)
}
```

Use `FormatCT.ANCOVA` to format CT data for GAPDH and MMP10.

```{r}
GAPDH.CT <- FormatCT.ANCOVA(ct.results.annotated$GAPDH)
MMP10.CT <- FormatCT.ANCOVA(ct.results.annotated$MMP10)

# remove 'ASM Media Control' specfication from treatment column (redundant information)
GAPDH.CT$Treatment <- gsub(" ","",str_split_i(GAPDH.CT$Treatment,"\\+",2))
MMP10.CT$Treatment <- gsub(" ","",str_split_i(MMP10.CT$Treatment,"\\+",2))

head(GAPDH.CT)
```

`JoinCTResults` joins the CT data for our target and reference gene into a single dataframe. Data is joined by matching a combination of Donor and Treatment. The result can be used in the ANCOVA method to estimate the treatment effect on the expression of the target gene, accounting for technical variability captured by the expression of the reference gene. Please see the section entitled "ANCOVA Method" for an example.

```{r}
JoinCTResults <- function(CT1, CT2, TreatmentCol="Treatment", TargetCol="Target.Name", DonorCol="Donor", CTCol = "Ct.Mean"){
  # create identifier that is combination of donor and treatment
  CT1$Group <- paste0(CT1[[DonorCol]]," ",CT1[[TreatmentCol]])
  CT2$Group <- paste0(CT2[[DonorCol]], " ", CT2[[TreatmentCol]])
  # get gene names captured in target columns
  CT1.gene <- CT1[[TargetCol]][1]
  CT2.gene <- CT2[[TargetCol]][1]
  
  # join CT data for the two genes by the group identifier, keeping only those groups that are captured in both dataframes
  # append gene name as a suffix to commonly named columns
  joined.results <- CT1[,c(DonorCol, TreatmentCol, "Group", CTCol)] |> 
    inner_join(CT2[,c("Group",CTCol)], by=join_by(Group), suffix = c(paste0(".",CT1.gene), paste0(".",CT2.gene)))
  
  return(joined.results)
}
```

Join the GAPDH and MMP10 data together using `JoinCTResults`. This data frame is formatted correctly for the ANCOVA method.

```{r}
CT.joined <- JoinCTResults(GAPDH.CT, MMP10.CT)
head(CT.joined)
```

`GraphCT` creates a plot that shows CT for two genes (target and reference) for each donor and each treatment condition. Samples from the same donor are linked with a line. Average CT for each gene across donors is represented with black dots/lines.

```{r}
GraphCT <- function(CTData, CT1Col="Ct.Mean.GAPDH", CT2Col="Ct.Mean.MMP10", TreatmentCol="Treatment", DonorCol="Donor", ylab = "CT"){
  
  # create dataframe for use with ggplot
  plot.df <- CTData |> 
    pivot_longer(cols = all_of(c(CT1Col, CT2Col)),
                 values_to = "CT",
                 names_to = "Gene")
  plot.df$LineGroup <- paste0(plot.df[[DonorCol]]," ",plot.df$Gene)
  
  # rename treatment column for group_by access
  # tidyverse makes it difficult to access columns via variable names, this is a workaround
  plot.df$AccessTreatment <- plot.df[[TreatmentCol]]
  
  # calculate average CT for each gene across each treatment group
  average.df <- plot.df |> 
    group_by(AccessTreatment, Gene) |> 
    summarise(meanCT = mean(CT)) |> 
    rename(AvgLineGroup=Gene)
  
  # plot CT by treatment group, colored by Donor
  p.obj <- ggplot(plot.df, aes_string(x=TreatmentCol, y="CT"))+
    geom_point(aes_string(shape="Gene", color = DonorCol), size=2.5)+
    geom_line(aes_string(group = "LineGroup", color = DonorCol))+
    ylab(ylab)+
    theme_minimal()+
    theme(axis.text = element_text(size=12),
          legend.text = element_text(size=12))
  
  # add lines representing average CT for each gene/treatment combination
  p.obj <- p.obj+
    geom_point(data=average.df, aes(x=AccessTreatment, y=meanCT, shape=AvgLineGroup), size=2.5, inherit.aes = F)+
    geom_line(data=average.df, aes(x=AccessTreatment, y=meanCT, group=AvgLineGroup), inherit.aes = F, linetype="dashed")
    
  return(p.obj)
}
```

The graph shows that expression of the reference gene GAPDH does not change with treatment. Conversely, there appears to be a slight decrease in MMP10 expression between DMSO and ETI (higher CT indicates less genetic material).

```{r warning=F, message=F}
GraphCT(CT.joined)
```

## Weighted CT

In some circumstances, we would want to weight the CT values by the amplification efficiency of the corresponding well or replicate group. The function for this transforms CT as follows:

$CT_w = \log_2(E) * CT$

Where $E$ is the estimated amplification efficiency. Below we define a function to weight CT by estimated amplification efficiency. We use the `MMP10.eff.estimates.reps` and `GAPDH.eff.estimates.reps` objects created in the amplification efficiency section of the tutorial.

```{r}
WeightCT <- function(CT.data, MMP10.E, GAPDH.E){
  # put data in dataframe format
  MMP10.E.df <- data.frame(Group = names(MMP10.E), E.MMP10 = MMP10.E)
  GAPDH.E.df <- data.frame(Group = names(GAPDH.E), E.GAPDH = GAPDH.E)
  
  # join efficiency data to CT data
  CT.w <- CT.data |> 
    left_join(MMP10.E.df, by=join_by(Group)) |> 
    left_join(GAPDH.E.df, by=join_by(Group))
  
  # Calculate weighted efficiency in a new column
  CT.w$CT.w.GAPDH <- log2(CT.w$E.GAPDH) * CT.w$Ct.Mean.GAPDH
  CT.w$CT.w.MMP10 <- log2(CT.w$E.MMP10) * CT.w$Ct.Mean.MMP10
  return(CT.w)
}

CT.joined.w <- WeightCT(CT.joined, MMP10.eff.estimates.reps, GAPDH.eff.estimates.reps)
```

We can update the CT graph to show the weighted CT. 

```{r message=F}
GraphCT(CT.joined.w, CT1Col = "CT.w.GAPDH", CT2Col = "CT.w.MMP10", ylab = "Weighted CT")
```

# ANCOVA Method

As mentioned previously, we can use the CT dataframe created above (formatted as shown in CT.joined) in the ANCOVA method for qPCR data analysis.

The model measures how treatment affects MMP10 expression (our target gene), controlling for donor and GAPDH expression levels (reference gene). Including GAPDH as an independent variable in the model controls for the influence of technical variation on the expression of the target gene and isolates the predicted treatment effect.  

```{r}
CT.model <- lm(Ct.Mean.MMP10 ~ Treatment + Donor + Ct.Mean.GAPDH, data = CT.joined)
summary(CT.model)
```

This analysis approach suggests that ETI has an effect on MMP10 expression in our sample, increasing the CT value by almost 1 (i.e. a doubling of expression). Given the parameters included in the model, one could make the following statement:

The data shows that ETI treatment increases MMP10 expression in primary human airway epithelial cells, accounting for differences between donors and any technical variation introduced by the qPCR technology as captured by the expression of the reference gene GAPDH.
